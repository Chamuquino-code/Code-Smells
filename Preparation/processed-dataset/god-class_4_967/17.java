/******************************************************************************/
protected void setToolTipTexts() {
    tf_initTemperature.setToolTipText("starting value for temperature");
    tf_minTemperature.setToolTipText("if temperature reaches this value, the algorithm finishes");
    tf_minDistance.setToolTipText("minimal distance, vertices should have to each other before causing more costs");
    tf_tempScaleFactor.setToolTipText("factor the temperature is multiplied every round");
    tf_maxRounds.setToolTipText("maximum number of rounds, if not finished by temperature before");
    tf_triesPerCell.setToolTipText("number of segments around a vertex. The vertex will be placed on each to find a new position. Costs are calculated for every segment, so don't choose your value too high");
    tf_lambdaNodeDistribution.setToolTipText("Factor, the costs of the node distribution function are multiplied. Low distances between Vertices make heigher costs");
    tf_lambdaBorderline.setToolTipText("Factor, the costs of the borderline function are multiplied. Border can be configured with \"max. width\" and \"max. height\" below. Vertices near or beyond cause higher costs");
    tf_lambdaEdgeLength.setToolTipText("Factor, the costs of the edge length function are multiplied. Long edges cause higher costs");
    tf_lambdaEdgeCrossing.setToolTipText("Factor, the costs of the edge crossing function are multiplied. For every crossing Edge the costs increase");
    tf_lambdaEdgeDistribution.setToolTipText("Factor, the costs of the edge distribution function are multiplied. This function evaluates the distances between edges and vertices. A low distance increases the costs");
    tf_lambdaNodeDistance.setToolTipText("Factor, the costs of the node distance function are multiplied. Nodes to close to each other or overlapping increases the costs");
    tf_boundsWidth.setToolTipText("width of the field the graph should be layouted on");
    tf_boundsHeight.setToolTipText("height of the field the graph should be layouted on");
    cb_computePermutation.setToolTipText("define if the vertices are computed every round with the same order or a random order (permutation)");
    cb_uphillMovesAllowed.setToolTipText("defines if moves of vertices are allowed, which increases the costs slightly");
    cb_useNodeDistribution.setToolTipText("switches the costfunction for node distribution on/off");
    cb_useBorderline.setToolTipText("switches the costfunction for borderline on/off");
    cb_useEdgeLength.setToolTipText("switches the costfunction for edge length on/off");
    cb_useEdgeCrossing.setToolTipText("switches the costfunction for edge crossings on/off");
    cb_useEdgeDistribution.setToolTipText("switches the costfunction for edge distribution on/off");
    cb_useNodeDistance.setToolTipText("switches the costfunction for node distance on/off");
    button_takeViewportSize.setToolTipText("takes the size of the viewport for the graph (FEATURE NOT IMPLEMENTED YET!!!)");
    cb_enableLayoutUpdate.setToolTipText("enables the algorithm to run, when vertices are removed/added");
    tf_lu_initTemperature.setToolTipText(tf_initTemperature.getToolTipText());
    tf_lu_minTemperature.setToolTipText(tf_minTemperature.getToolTipText());
    tf_lu_minDistance.setToolTipText(tf_minDistance.getToolTipText());
    tf_lu_tempScaleFactor.setToolTipText(tf_tempScaleFactor.getToolTipText());
    tf_lu_maxRounds.setToolTipText(tf_maxRounds.getToolTipText());
    tf_lu_triesPerCell.setToolTipText(tf_triesPerCell.getToolTipText());
    tf_lu_lambdaNodeDistribution.setToolTipText(tf_lambdaNodeDistribution.getToolTipText());
    tf_lu_lambdaBorderline.setToolTipText(tf_lambdaBorderline.getToolTipText());
    tf_lu_lambdaEdgeLength.setToolTipText(tf_lambdaEdgeLength.getToolTipText());
    tf_lu_lambdaEdgeCrossing.setToolTipText(tf_lambdaEdgeCrossing.getToolTipText());
    tf_lu_lambdaEdgeDistribution.setToolTipText(tf_lambdaEdgeDistribution.getToolTipText());
    tf_lu_lambdaNodeDistance.setToolTipText(tf_lambdaNodeDistance.getToolTipText());
    tf_lu_boundsWidth.setToolTipText(tf_boundsWidth.getToolTipText());
    tf_lu_boundsHeight.setToolTipText(tf_boundsHeight.getToolTipText());
    tf_lu_method_neighborsDepth.setToolTipText("");
    tf_lu_method_perimeterRadius.setToolTipText("");
    tf_lu_method_perimeterRadiusInc.setToolTipText("");
    cb_lu_computePermutation.setToolTipText(cb_computePermutation.getToolTipText());
    cb_lu_uphillMovesAllowed.setToolTipText(cb_uphillMovesAllowed.getToolTipText());
    cb_lu_useNodeDistribution.setToolTipText(cb_useNodeDistribution.getToolTipText());
    cb_lu_useBorderline.setToolTipText(cb_useBorderline.getToolTipText());
    cb_lu_useEdgeLength.setToolTipText(cb_useEdgeLength.getToolTipText());
    cb_lu_useEdgeCrossing.setToolTipText(cb_useEdgeCrossing.getToolTipText());
    cb_lu_useEdgeDistribution.setToolTipText(cb_useEdgeDistribution.getToolTipText());
    cb_lu_useNodeDistance.setToolTipText(cb_useNodeDistance.getToolTipText());
    button_lu_takeViewportSize.setToolTipText(button_takeViewportSize.getToolTipText());
    comb_lu_Method.setToolTipText("choose a method for Layout Updating. This method determines, which of the Neighbors around the inserted Vertices are also new layouted in order to make place for the Layout of the inserted Vertices.");
    tf_lu_method_neighborsDepth.setToolTipText("Neighbors are once again layouted if their distance to the inserted vertices is lower or equal this value");
    tf_lu_method_perimeterRadius.setToolTipText("Neighbors within this radius around the initial position of inserted vertices are once again layouted in order to make place for the Layout of the inserted Vertices");
    tf_lu_method_perimeterRadiusInc.setToolTipText("If more than one Vertice is inserted and has the same initial Position as another the perimeter radius is increase by this value");
    tf_lu_clustering_factor.setToolTipText("Factor the creation of clusters. A lower value leads to more clusters, with smaller size, a higher value to fewer, bigger clusters");
    tf_lu_clustering_moveScale.setToolTipText("Scales the movement of clusters. Possible values are between 0.0 and 1.0. A small value ensures, that clusters move slow and over short distances.");
}
